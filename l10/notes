Математический сопроцессор

Любое разрядное число можно представить в виде континуальной сетки

Задача - считать штуки, которые не являются целыми числами


Отдельное устройство, подкл к шине
Может работать параллельно с основным процессором
Хотя сейчас матсопроц он встроен в сам процессор
Но он все еще может работать параллельно

И эта параллельность вносит свои корективы в прогу

У него должно быть какое-то окружение (как например регистры у обычного процессора)
Что-то что доступно только процу

Сопроц имеет свои регистры (это его окружение)
он имеет доступ к памяти (может читать очередную инструкцию для него оттуда
Почему плавающая точка? Потому что они дают бОльшую точность!
Но есть и обратная проблема - числа с плавающей точкой не дают нужной скорости! Особенно на процах, на которых нет матсопроцов (там эмуляция)

Регистры
r0-r7 каждый 80битный

Системные (состояние и настройка):
swr - status word register отвечает за основное состояние (что-то типа flags)
cwr - control word register - составление параметров
twr - tag word register - позволяет узнать, что хранится в этих регистрах
ipr - указатель на инструкцию
dpr - указатель на данные

Инструкции можно разбить на:
    управление
    пересылка данных (из памяти загрузить вещественное или целое значение в нужном формате)
    алгебраические функции (+-/* sqrt, ** и штуки связанные с многочленами, log, sin, cos)

Ряд тейлора не нужен! Все в железе!

Типы данных
IEEE-754 описаны туть
Есть один выд бит для знака, биты под экспоненту, биты для fraction
ну короче чиселки как в физике когда записывали
т.к. основание сс 2, то в целой части всегда 1, т.е. мы можем ее не хранить и просто записать только после запятой
Ну еще оно сдвинуто на (2**(n-1) - 1), n - длина экспоненты

Есть тип, который не так много бит занимает, побольше, и весь регистр.
1 под знак, под экп 11бит под дробь 52бит


на самом деле мы можем делать операции не только над вещественными и целыми числами

для того, который весь регистр занимает - в 63 бите написано, содержит ли число целое число, или число с плавающей точкой

целочисленные:
выделен бит под знак

поэтому, чтобы поменять знак, достаточно только поменять старший бит

также три типа по размерам

bcd формат
позволяет проводить операции над десятичными числами
(используется например в банках)
Вообще в целом когда нам нужно работать с десятичной сс, при некоторой точности в десятичном смысле
Чтобы не было приколов по типу 0.1+0.2 = 0.300000001

Идея в чем? Выделяется 4 бита на каждое 10чное значение.
При операциях может произойти переполнение, которое мы должны перенести в следующий такой "разряд"

Если количество возможных значений не существенно критично и нам нужно чтобы при переводе в десятичную сс, не было странных ошибок округления



Мы не можем делать оперциии по типу mov r0, 10
Мы всегда кладем значение на стек регистров
прикол в том, что это стек зациклен и состоит он из регистров)
К регистру можно обращаться через вершину стека, называемую st0
А к тому который только положили через st1

mm0, mm1, и т.д. - регистры multimedia, они являются частью регистров r, занимают меньшие биты

Мы можем положить на стек значение и снять с него
Если весь стек заполнен, то он просто перезапишет старое значение
т.е. на стеке больше 8 значений храниться не может


Регистр статуса
(типа флаги)
Младшие 8 бит - отвечают за операции, которые уникальны для матсопроц
например overflow - не хватило точности
underflow - не хватило точности для дробной части
деление на ноль - это не исключительная ситуация, просто поднимается флаг ZERO DIVIDE
0, всякие бесконечности и нечисла считаются ненормализованными и с ними поднимается флаг denormalized operand
Если мы читаем со стека то, что мы туда не положили, то у нас поднимается флаг Stack Fault
Error Summary Status - поднимается, когда поднялся какой-то флаг

Остальные соответсвуют флагам регистра флагов
Т.е. можно это считать в ah, а потом сохранить в регистр флагов

вообще там еще битики захватятся, ну мы посмотрим, что там должно лежать в регистре флагов

Кстати, на самом деле, когда мы записываем в какой-то регистр на основном процессоре, не факт, что он пойдет в один и тот же физический процессор) На самом деле сейчас это работает скорее как виртуальная машина, которая всех обманывает


Control word
гораздо меньше используемых битов
Младщие биты соответствуют пяти битам из регистра статуса и отвечают за то, стоит ли генерировать исключение
precision control и rounding control -  позволяют определять правила, как округлять

Есть четыре операции, как округлять и для точности


Примерно, что они делают? Это не с какой-то там точностью после запятой, это прям к целому-целому
Математическое округление
округление вверх
округление вниз
к ближайшему целому (чем это отличается от математического? Различие в знаке! в математическом -2.5 = -2, а здесь -2.5 = -3)


Регистр тэгов
Сопроц помнит, что мы моложили в стек благодаря этому рег
он елится по два бита на группы
00 - valid
01 - zero
10 - special: invalid (nan, unsupported), infinity or denormal
11 - empty

т.е. 8 тэгов по два бита каждый


Нельзя обращаться к данным, которые мы не клали на стек
