Чтобы не было проблемы, что в utf-8 какой-то не первый байт равен " начало на самом деле заменяется на 10б,а в самом первом заменяется один бит на 1 на каждый следующий байт, начинающийся с 10

.include работает как в C  и просто подставляет код

Лучше всегда явно писать секции, чтобы вдруг подставленный код не подставил .data,чтобы код, который должен был быть в .text не оказался в дата

Метки не должны совпадать

Почитать про директиву .if
xchg - меняет значение в двух регистрах

Написали свою версию в коде с помощью макросов

С макросами нужно жить очень аккуратно! Они просто подставляют весь код! Даже метки. И если несколько раз вызвать, то он попытается определить метку несколько раз и упадет

Поэтому нужно объявляеть локальные метки!
Они записываются только числа

1:
    какой-то код
    loop 1b // b озн назад
    (или loop 1f) // f озн вперед

Они всегда идут к самой ближней метке (вперед или назад соотв)

Макрос можно объявлять хоть в .text, хоть в .data

.quad - объявление 8 байт

Короче, можно делать рекурентные макросы
Вообще макросы нужны, чтобы можно было что-то посчитать на этапе транслирования, а не исполнения

Еще про кодировки поговорили довольно очевидные вещи

Выравнивание 

.align 16 берет все, что было выше и добивает до границы 16, забивая нулями
Зачем это нужно? Процессору проще жить, когда данные выровнены по 16 байт, это стоит делать ради оптимизации. И когда используешь C-шные библиотеки. Они могут сломаться, если данные не выровнены

Иногда warning выбрасывается, когда данные не выровнены
