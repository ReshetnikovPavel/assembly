loop не меняет флаги
dec точно меняет zero flag

pushf чтобы запушить флаги (таким образом сохранить их, чтобы после того, как кто-то их поменяет, мы могли достать такие же)
popf

но так делать долго, т.к. записывать в память долго

lahf - сохраняет в ah регистр флагов 
sahf - загружает из ah регистр флагов

dec меняет кроме zf еще другие флаги, например overflow (зн в рег переполн)
lahf не сохраняет overflow

в rcx в нашем случае не будет переполн, т.к. мы прыгаем когда 0, т.е. отрицательных чисел не будет

мы дог в al зап overflow flag
x:
    inc %al // этот (если был ноль, то переполнение будет, иначе его не будет)
    sahf    // и этот полностью восст рег флагов
    nop
    lahf
    mov $0xff, %al
    jo d
    mov $0, %al
d:
    dec %rcx // Можно через sub, не проблема. Забавный факт, что можно просто через add то же самое сделать, если развернем число
    // add %rcx, $0xfffffffffffffffff (сколько-то f-ок)
    jnz x
    sahf

    mov $60, %rax

Вот это все - это имитация операции loop. Но loop все равно быстрее)
Много операций, поэтому loop все равно медленный

test %rcx, %rcx // то же, что %rcx & %rcx (побитовое и, для проверки на ноль можно использовать)
or %rcx, %rcx - побит или


Поработали с gdb, поставили peda для цветов
Иногда в нем инструкции, которые были до текущей отображаются неправильно. Почему?
Пример
0x65 0x10 0x90
Пусть это была mov ax, 0x9010 (помним, что у нас little-endian)
пусть на ней был breakpoint
dgb смотрит на rip, читает назад на сколько-то байтиков назад. Но отступил он в середину инструкции и начал читать их не с того места, где ннужно было (скорее всего это так работает). После пойнтера уже все должно быть хорошо, т.к. текущая инструкуция читается правильно.

r - для передвчи аргументов(?)

отладчик выступает как ОС и он умеет писать в readonly секции (например в .text), в отличие от нашей программы. Например, записать, что по какой-то метке находится breakpoint (вернее записать нужную инструкцию на то место (int 3))

breakpoint должен занимать столько байт, сколько мин размер инструкции в проце, чтобы все работало (ну если мы правильно поставим брейкпойнт, а не на середину инструкции)
Чтобы невалидных брейпойнтов не было, брейкпоинт должен занимать 1 байт, но на примере у нас почему-то было 2, посмотреть дома
int 3 генерируется прерывание, управление передается обработчику прерываний. Сохраняются метка cs, flags (кроме trap flag, он сбрасывается, ведь иначе вечный цикл). Как же он в итоге восстанавливается, когда мы возвращаемся в нашу программу? iret

Почитать про инструкции sbb и das
что-то нелинейные данные склеивает и они линейные... Я выпал
