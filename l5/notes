Типы данных


Как отрицательное число (очевидно, что его интерпретируем как знаковое) из 8-битного перевести в 16-битное? Берем старший бит и копируем его слева. (Если было отрицательное число, то скопируются единицы, а если положительное, то нули) для этого есть спец операции

для float есть спец сопроцессор (x87)
8 регистров (r0-r7) (название как у общего назначения, но там c r8 начинается)
На самом деле оно на собственном стеке реализовано, а не прямо так как мы написали
рег занимает 80 байт
первый бит знаковый, затем 15 бит экспонента, 64 бита под мантиссу
Прикол в том, что это не дабл. Сейчас вообще матсопроц не спользуется, там есть какие-то векторные расширения
Формат у чисел тот же, просто количество бит другое
mmx нужны были регистры, и тогда решили у матсопроц откусить 64 бита, используемые для мантиссы (Т.е. матсопроц вместе с mmx использоватьнельзя)

Числовые типы (Важно! Это все равно интерпретировать можем как захотим!)
.byte
.word (.short)
.long (.int)
.float (.single)
.double

Здесь нет типа для знаковых! Мы не говорим о знаке, только о размере! Знак мы должны сами интерпретировать

Строки
.ascii
.asciiz - строки в C-шном виде. Т.е. оно просто в конце дописывает \0

Представим: траслятор дошел до " после .ascii и он просто выделил нужное число байт. Ему плевать на кодировку! Он будет кодировать в той кодировке, в которой был записан файл! Т.е. .ascii может быть и не ascii
Но погодите! А что будет, если какие-то байты внутри точно такие же как у " в ascii? (доп вопрос дз)
Кодировку он не может физически интерпретировать. Да, иногда вначале пишут какая кодировка, но она ж просто рекомендация

еще есть
.space - зап нулевыми байтами
.fill заполняет нужными значениями

Все предпроцессинговые штуки довольно простые) И да, все эти штуки во время предпроцессинга исполняюстя

Массивы?
Вот так же как .space, .fill и остальное



man readelf
как добраться до секций
