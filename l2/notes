Существуют еще регистры устройств (у клавиатуры, матсопроцессор...)
регистры нужны для хранения и для получения/сохранения состояния (нек инстр ведут себя по-разному из-за разных зн в регистрах (регистр флагов))

для float ST0-ST7 (80 bit)
MMX (MM0-MM7)(multi-media)
SSE (XMM0 - XMM15) 128bit
YMM 256bit
ZMM 512bit
RIP - текущ инстр
RFLAGS 64bit

мин ед адрес 1 байт


gdtr (glob decr tabl reg) ldtr (local decr tabl reg) idtr(interrupt decr tabl reg) (48bit)


Segment descriptor
limit (длина) base (началo) access (права доступа)

в стр адр не надо хранить lim
не нужно делать проверку, что мы не вышли за lim



Раньше 1024 бит выд на табл вект прерыв
кажд вектор 4 бит
segment offset

mov 100, %al (al - в low часть ax)

(ко всем внутр есть доступ)
r*x 64b
e*x 32b
*x 16b
*l *h 8b

к si di sp bp тоже можно в виде sil dil sil bil чтоб к младш части 8bit
r8 - r15 тоже делятся на младшие части 
                                    r10d
                                    r10w
                                    r10b

mov $10, %ax
mov %ax, %cs (сразу нельзя, это не рег общ назн)

push - зап в стек

push 10
pop cs - еще можно чз стек записать

в rip можно записать чз jmp (ну он как бы как раз на инструкцию указывает, логично)

Регистр флагов

carry flag
gthdsq akfu
пусть мы сделали 
add al, 10
и чтобы мы моглм сложить два числа нам нуж еще один бит, вот он есть

второй флаг (флаг паритета)
add 1010, 101
выст, если все 1

zero flag=1, если рез равен 0
sub 100, 100

zf и cf позволяют делать условные перех
jz (или je) - jump if zero flag
ja - анализируют carry flag
jb - 

sign flag
когда работаем со знаковыми
(как работают знаковые числа? Берем 1, инвертируем, добавляем 1, получаем -1. То же, что и по модулю) (нет такого понятия как +0 -0)
когда устанавливается parry bit можно делать переход


sub x,y
(x не меняется, но устанавливаются флаги)
cmp x,y

Есть флаг для дебага, с помощью которого происходит аппаратное прерыв, используемое отладчиком

interrupt enable flag - позволяет выключить маскируемые прерыв (иногда нужно блокировать прерывания до того, как что-то запишем. Чтобы не было такого, что мы только что-то одно записали и дальше пошли)

direction flag
сущ инстр для работы с массивами, напр:
movsb - берет байтик и направляет его в адрес rdi
а можно добавить префикс rep
rep movsb
пусть в rcx лежит10
rsi += 1
rdi += 1

два массива, в одном что-то есть, а в др нет
rsi - на полезные
rdi - на мусор
и оно на 10 значений скопирует что-то из rsi и запиш в rdi, и применит что-то на rdi


sp - stack pointer
стек растет от старш бит к младш
sp уменшается на 8 байт при push
pop ув sp и возвр зн

cx - используется как счетчик (сколько раз указано, что столько раз и повт, например)

dx - как старш часть для mul (умнож)
mul bx
для 16bit * 16bit нужно 32 бита
mul bx - это ax * bx -> dx:ax (старш часть в dx; младш в ax) (должны быть целочисл и беззнак)
div bx - это  dx:ax / bx -> частное в ax; dx:ax % bx -> а остаток в dx (не забывайте занулять dx!) (если в dx и в ax большие числа, то число может не влезть в ax, на что бы мы не делили и будет "деление на 0"
