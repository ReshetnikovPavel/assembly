Если .asсii записать в .text, то оно будет интерпретироваться как инструкция и вся программа сломается. (x86 - это cisc, поэтому длина инструкции неодинаковая)
Инструкция - это просто набор байт

inc - ув числ на 1
dec - ум числ на 1

lea - load effective address (как mov, но передаем адрес)

L: какой-то лейбл
L(rax, rbx, x) - каких-либо штук отсюда может не быть
x принадлеж {1, 2, 4 ,8}
И это считается как L+rax-rbx*x

lea загружает не число, а число по адресу

lea L(rax, rbx, x), rax
так, например, можно умножить на 5: lea L(rax, rax, 4), rax
L+rax+rbx*x

jz и je - то же самое, но для читаемости лучше после сравнения использовать je, а после вычитания jz, например

ja (above) беззнаковый, jb (below) беззнаковый, jg (greater) знаковый, jl (less) знаковый

Можно даже jza - jump zero above (или 0 или больше)

call (типа вызов функции с помощью стека)
stack pointer ум на 8 байт, на нем новый instruction pointer, и к нему присваеваем адрес или число
Типа push и jmp

ret (типа return)
снимает со стека сохраненный адрес и кладет в него instruction pointer
Типа pop и jmp


shr и shl - побитовый сдвиг
shr - вправо, shl - влево
Можно исп для умн на степень двойки, ну как обычно делаем


movs - уже говорили

lods - взависимости от суффикса загр в rax (eax, ax и т.д)
stos

ins работа с портами ввода-вывода. те же mov, но там свои операции in и out. из порты в память
outs из памяти в порты
(они нам вроде не доступны, они для ос)

приставки rep, repe repne для повторения. Эти операции не атомарные! Это просто цикл из одной строчки


push и pop (вроде понятно)
pusha и popa (сохраняет все регистры 16бит на стек)
pushad и popad (сохр на стек все 32 бит регистры)
Читайте документацию :) она есть в репо на гх

x87 - расширение для float арифм
Есть еще векторные расширения, позв делать неск оп за одно действие

Например в sse есть 128 бит регистр, его можно под на 4 регистра и делать сразу 4 операции за одно действие (иногда существно ускоряет работу программы)

*Операция mov*
без всего, что обсудили, можно обойтись только с помощью mov
Зачем это? Испортить жизнь реверс-инженерам >:)
(примеры на презентации)


_start:
    mov $100500, %rcx
x:
    nop
    loop x

или
_start:
    mov $100500, %rci
x: 
    nop
    dec %rcx
    jnz x

Эти две штуки делают то же самое, но одна из них работает медленнее
